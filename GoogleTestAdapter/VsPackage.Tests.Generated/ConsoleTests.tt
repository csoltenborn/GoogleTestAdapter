<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(EnlistmentRoot)\out\binaries\GoogleTestAdapter\$(ConfigurationName)\Tests.Common\GoogleTestAdapter.Tests.Common.dll" #>
<#@ assembly name="$(EnlistmentRoot)\out\binaries\GoogleTestAdapter\$(ConfigurationName)\Tests.Common.EndToEnd\GoogleTestAdapter.Tests.Common.EndToEnd.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="GoogleTestAdapter.Tests.Common" #>
<#@ import namespace="GoogleTestAdapter.Tests.Common.EndToEnd" #>
<#@ import namespace="GoogleTestAdapter.Tests.Common.Helpers" #>
<#@ output extension=".cs" #>
<#
//    System.Diagnostics.Debugger.Launch();
//    System.Diagnostics.Debugger.Break();
	string csvFile = Host.ResolvePath("GTA_Console.csv");
	TestcaseCsvReader reader = new TestcaseCsvReader(csvFile);
#>
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using GoogleTestAdapter.Tests.Common;
using GoogleTestAdapter.Tests.Common.EndToEnd;
using GoogleTestAdapter.Tests.Common.ResultChecker;
<# if (AbstractConsoleIntegrationTests.ShouldGenerateVsixTests()) { #>
using GoogleTestAdapter.Tests.Common.EndToEnd.VisualStudio;
<# } #>
using static GoogleTestAdapter.Tests.Common.TestMetadata.TestCategories;

namespace GoogleTestAdapter.VsPackage
{

	public abstract class AbstractConsoleTests
	{
		private readonly string _solutionFile;
		protected readonly string TestAdapterDir;

		protected AbstractConsoleTests()
		{
			AbstractConsoleIntegrationTests.GetDirectories(out TestAdapterDir, out _solutionFile);
		}

        private void RunTestsAndCheckOutput(string typeName, string arguments, [CallerMemberName] string testCaseName = null)
        {
            TrxResultChecker resultChecker = new TrxResultChecker(_solutionFile);
            resultChecker.RunTestsAndCheckOutput(typeName, arguments, testCaseName);
        }

        protected abstract string GetAdapterIntegration();
		protected string GetLogger()
		{
			return AbstractConsoleIntegrationTests.GetLogger();
		}

		<#
		List<Line> lines = reader.GetObjects();
		IDictionary<string, string> executables = new Dictionary<string, string>();
		foreach (Line line in lines)
		{
			if (!executables.ContainsKey(line.TestFile))
				executables.Add(line.TestFile, line.ActualTestFile);
		#>

		public virtual void <#= line.MethodName #>()
		{
			string arguments = GetAdapterIntegration();
			arguments += @"<#= line.Arguments #>";
            RunTestsAndCheckOutput(GetType().Name, arguments);
		}
		<# } #>

		<# foreach (string executable in executables.Keys) { #>

		public virtual void List_TestsOf_<#= executable #>()
		{
		    string testExecutable = @"<#= executables[executable] #>";
			string arguments = GetAdapterIntegration() + @" /ListTests:""" + testExecutable + @"""";
			if (!testExecutable.Contains("_x86") && !testExecutable.Contains("_x64"))
				arguments +=  " /Settings:\"\"" + TestResources.UserTestSettingsForListingTests + "\"\"";
            string resultString = AbstractConsoleIntegrationTests.RunExecutableAndGetOutput(_solutionFile, arguments);
			string[] resultLines = resultString.Split('\n');
			resultLines = resultLines.Where(l => l.StartsWith("    ")).Select(l => l.Trim()).ToArray();
			for (int i = 0; i < resultLines.Length; i++)
			{
				resultLines[i] = Regex.Replace(resultLines[i], "Information:.*", "");
			}	
			resultString = string.Join("\n", resultLines);
            // ReSharper disable once AssignNullToNotNullAttribute
			string projectDir = Path.Combine(Path.GetDirectoryName(_solutionFile), @"..\GoogleTestAdapter\VsPackage.Tests.Generated");
            new ResultChecker(Path.Combine(projectDir, "GoldenFiles"), Path.Combine(projectDir, "TestErrors"), ".txt")
                // ReSharper disable once ExplicitCallerInfoArgument
				.CheckResults(resultString, GetType().Name);
		}
		<# } #>

	}


	[TestClass]
	public class ConsoleDllTests : AbstractConsoleTests
	{
        protected override string GetAdapterIntegration()
        {
            return GetLogger() + @"/TestAdapterPath:" + TestAdapterDir;
        }

		#region method stubs for code coverage

		<# foreach (Line line in lines) { #>

		[TestMethod]
        [TestCategory(EndToEnd)]
		public override void <#= line.MethodName #>()
		{
			base.<#= line.MethodName #>();
		}
		<# } #>

		<# foreach (string executable in executables.Keys) { #>

		[TestMethod]
        [TestCategory(EndToEnd)]
		public override void List_TestsOf_<#= executable #>()
		{
			base.List_TestsOf_<#= executable #>();
		}
		<# } #>

		#endregion
	}

	<# if (AbstractConsoleIntegrationTests.ShouldGenerateVsixTests()) { #>
	[TestClass]
	public class ConsoleVsixTests : AbstractConsoleTests
	{
		private static Vs VS;

        [ClassInitialize]
        public static void InstallVsix(TestContext testContext)
        {
			VS = new Vs();
            VS.SetupVanillaVsExperimentalInstance("", testContext.TestName);
        }

        [ClassCleanup]
        public static void Cleanup()
        {
            VS?.CleanVsExperimentalInstance();
			VS = null;
        }

        protected override string GetAdapterIntegration()
        {
            return GetLogger() + @"/UseVsixExtensions:true";
        }

		#region method stubs for code coverage
		<# foreach (Line line in lines) { #>

		[TestMethod, Ignore]
        [TestCategory(EndToEnd)]
		public override void <#= line.MethodName #>()
		{
			base.<#= line.MethodName #>();
		}
		<# } #>

		<# foreach (string executable in executables.Keys) { #>

		[TestMethod, Ignore]
        [TestCategory(EndToEnd)]
		public override void List_TestsOf_<#= executable #>()
		{
			base.List_TestsOf_<#= executable #>();
		}
		<# } #>

		#endregion

	}

    [TestClass]
    public class ConsoleVsixIntegrationTests : AbstractConsoleIntegrationTests
    {
		private static Vs VS;

        [ClassInitialize]
        public static void InstallVsix(TestContext testContext)
        {
			VS = new Vs();
            VS.SetupVanillaVsExperimentalInstance("", testContext.TestName);
        }

        [ClassCleanup]
        public static void Cleanup()
        {
            VS?.CleanVsExperimentalInstance();
			VS = null;
        }

        protected override string GetAdapterIntegration()
        {
            return GetLogger() + @"/UseVsixExtensions:true";
        }

        #region method stubs for code coverage

        [TestMethod, Ignore]
        [TestCategory(EndToEnd)]
        public override void Console_ListDiscoverers_DiscovererIsListed()
        {
            base.Console_ListDiscoverers_DiscovererIsListed();
        }

        [TestMethod, Ignore]
        [TestCategory(EndToEnd)]
        public override void Console_ListExecutors_ExecutorIsListed()
        {
            base.Console_ListExecutors_ExecutorIsListed();
        }

        [TestMethod, Ignore]
        [TestCategory(EndToEnd)]
        public override void Console_ListSettingsProviders_SettingsProviderIsListed()
        {
            base.Console_ListSettingsProviders_SettingsProviderIsListed();
        }

        #endregion

    }
	<# } #>

}

<#+

    class Line
    {
        internal string TestFile;
        internal string ActualTestFile;
		internal bool SettingsFile;
		internal string ActualSettingsFile;
		internal string TestCaseFilter;
		internal bool EnableCodeCoverage;
		internal bool InIsolation;

		internal string MethodName 
		{
			get 
			{
				string settings = SettingsFile ? "_Settings" : "";
				string codeCoverage = EnableCodeCoverage ? "_Coverage" : "";
				string isolation = InIsolation ? "_Isolation" : "";
				string filter = TestCaseFilter == "none" ? "" : "_" + TestCaseFilter;

				string result = TestFile + settings + codeCoverage + isolation + filter;

				result = result.Replace(".", "_");
				result = result.Replace("=", "_EQ_");
				result = result.Replace("|", "_OR_");
				result = result.Replace("&", "_AND_");

				if (result.Contains("*"))
					result = "NEG_" + result.Replace("*", "");

				return result;
			}
		}

		internal string Arguments
		{
			get
			{
				string arguments = " \"\"" + ActualTestFile + "\"\"";

				if (SettingsFile)
					arguments += " /Settings:\"\"" + ActualSettingsFile + "\"\"";

				if (!"none".Equals(TestCaseFilter))
					arguments += " /TestCaseFilter:\"\"" + TestCaseFilter + "\"\"";

				if (EnableCodeCoverage)
					arguments += " /EnableCodeCoverage";

				if (InIsolation)
					arguments += " /InIsolation";

				return arguments;
			}
		}
    }
	
    class TestcaseCsvReader : CsvReader<Line>
    {
        internal TestcaseCsvReader(string csvFile) : base(csvFile, '\t', true) { }

        protected override Line GetObject(string[] columns)
        {
            bool settingsFile = bool.Parse(columns[1]);
            return new Line
            {
                TestFile = columns[0],
                ActualTestFile = GetActualFile(columns[0]),
                SettingsFile = settingsFile,
                TestCaseFilter = columns[2],
                EnableCodeCoverage = bool.Parse(columns[3]),
                InIsolation = bool.Parse(columns[4]),
				ActualSettingsFile = settingsFile 
					? TestResources.UserTestSettingsForGeneratedTests 
					: ""
            };
        }

		private string GetActualFile(string key)
		{
			switch(key)
			{
				case "SampleTests":
					return TestResources.SampleTests;
				case "LoadTests":
					return TestResources.LoadTests;
				case "HardCrashingSampleTests":
					return TestResources.HardCrashingSampleTests;
				case "X861":
					return TestResources.X86StaticallyLinkedTests;
				case "X862":
					return TestResources.X86ExternallyLinkedTests;
				case "X641":
					return TestResources.X64StaticallyLinkedTests;
				case "X642":
					return TestResources.X64ExternallyLinkedTests;
				default:
					throw new Exception("Unknown test executable key: " + key);
			}
		}

    }

#>